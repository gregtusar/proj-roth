"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path_1 = require("path");
var config_1 = require("./config");
var helpers_1 = require("./helpers");
var chalk_1 = __importDefault(require("chalk"));
var logger = __importStar(require("./logger"));
exports.DEFAULTS = {
    contextPath: './src/context.ts',
    resolversPath: './src/graphql/',
    typesPath: './src/types.ts',
    ejectFilePath: './src/server.ts',
    output: {
        typegenPath: './.yoga/nexus.ts',
        schemaPath: './src/schema.graphql',
    },
    prisma: {
        /**
         * Do not use that as a default value, this is just a placeholder
         * When `datamodelInfo` isn't provided, we're importing it from `DEFAULT_META_SCHEMA_DIR` defined below
         */
        datamodelInfo: {
            schema: { __schema: null },
            uniqueFieldsByModel: {},
            clientPath: '',
            embeddedTypes: [],
        },
        /**
         * Do not use that as a default value, this is just a placeholder
         * When `client` isn't provided, we're importing it from `datamodel.clientPath`
         */
        client: {
            $exists: null,
            $graphql: null,
        },
    },
    expressPath: './src/express.ts',
};
exports.DEFAULT_META_SCHEMA_DIR = './.yoga/nexus-prisma/';
/**
 * - Compute paths relative to the root of the project
 * - Set defaults when needed
 */
function normalizeConfig(config, projectDir) {
    var outputConfig = {
        contextPath: contextPath(projectDir, config.contextPath),
        resolversPath: resolversPath(projectDir, config.resolversPath),
        typesPath: typesPath(projectDir, config.typesPath),
        ejectFilePath: ejectFilePath(projectDir, config.ejectFilePath),
        expressPath: expressPath(projectDir, config.expressPath),
        output: output(projectDir, config.output),
        prisma: prisma(projectDir, config.prisma),
    };
    return outputConfig;
}
exports.normalizeConfig = normalizeConfig;
/**
 * Returns either a value from yoga.config.ts or from the defaults
 */
function inputOrDefaultValue(input, defaultValue) {
    return input ? input : defaultValue;
}
/**
 * Returns either a user inputted path, or the default one
 * Join the path with the root project dir
 */
function inputOrDefaultPath(projectDir, input, defaultValue) {
    var path = inputOrDefaultValue(input, defaultValue);
    return path_1.join(projectDir, path);
}
/**
 * Optional input path
 * If @input is provided, @path has to exists
 */
function optional(path, input, errorMessage) {
    if (!fs_1.existsSync(path)) {
        if (input) {
            logger.error(errorMessage);
            process.exit(1);
        }
        return undefined;
    }
    return path;
}
/**
 * Optional required path
 * @path has to exists (from @input or @default)
 */
function requiredPath(path, errorMessage) {
    if (!fs_1.existsSync(path)) {
        logger.error(errorMessage);
        process.exit(1);
    }
    return path;
}
function buildError(projectDir, filePath, propertyName) {
    var resolvedPath = filePath.startsWith('.')
        ? filePath
        : path_1.relative(projectDir, filePath);
    return "Could not a find a valid `" + chalk_1.default.yellow(propertyName) + "` at `" + chalk_1.default.yellow(resolvedPath) + "`";
}
function contextPath(projectDir, input) {
    var path = inputOrDefaultPath(projectDir, input, exports.DEFAULTS.contextPath);
    return optional(path, input, buildError(projectDir, path, 'contextPath'));
}
function resolversPath(projectDir, input) {
    var path = inputOrDefaultPath(projectDir, input, exports.DEFAULTS.resolversPath);
    return requiredPath(path, buildError(projectDir, path, 'resolversPath'));
}
function typesPath(projectDir, input) {
    var path = inputOrDefaultPath(projectDir, input, exports.DEFAULTS.typesPath);
    return optional(path, input, buildError(projectDir, path, 'typesPath'));
}
function ejectFilePath(projectDir, input) {
    var path = inputOrDefaultPath(projectDir, input, exports.DEFAULTS.ejectFilePath);
    return optional(path, input, buildError(projectDir, path, 'ejectFilePath'));
}
function expressPath(projectDir, input) {
    var path = inputOrDefaultPath(projectDir, input, exports.DEFAULTS.expressPath);
    return optional(path, input, buildError(projectDir, path, 'expressPath'));
}
function output(projectDir, input) {
    if (!input) {
        input = {};
    }
    var typegenPath = inputOrDefaultPath(projectDir, input.typegenPath, exports.DEFAULTS.output.typegenPath);
    var schemaPath = inputOrDefaultPath(projectDir, input.schemaPath, exports.DEFAULTS.output.schemaPath);
    return {
        typegenPath: typegenPath,
        schemaPath: schemaPath,
    };
}
function client(projectDir, input, datamodelInfo) {
    if (input === undefined) {
        var clientPath = requiredPath(path_1.join(projectDir, datamodelInfo.clientPath, 'index.ts'), buildError(projectDir, datamodelInfo.clientPath, 'prisma.client') + ". Try running " + chalk_1.default.yellow('prisma deploy') + " to generate the needed files.");
        return helpers_1.importFile(clientPath, 'prisma', true);
    }
    return input;
}
exports.client = client;
function datamodelInfo(projectDir, input) {
    var datamodelInfoPath = inputOrDefaultPath(projectDir, input, path_1.join(exports.DEFAULT_META_SCHEMA_DIR, 'datamodel-info.ts'));
    return helpers_1.importFile(requiredPath(datamodelInfoPath, buildError(projectDir, datamodelInfoPath, 'prisma.datamodelInfoPath') + ". Try running " + chalk_1.default.yellow('prisma deploy') + " to generate the needed files."), 'default');
}
exports.datamodelInfo = datamodelInfo;
function prisma(projectDir, input) {
    var hasPrisma = !!config_1.findPrismaConfigFile(projectDir);
    // If `prisma` undefined and no prisma.yml file, prisma isn't used
    if (input === undefined && !hasPrisma) {
        return undefined;
    }
    // If `prisma` === true or `prisma` === undefined but a prisma.yml file is found
    // Use all the defaults
    if (input === undefined && hasPrisma) {
        input = {};
    }
    var importedDatamodelInfo = datamodelInfo(projectDir, input.datamodelInfoPath);
    var importedClient = client(projectDir, input.client, importedDatamodelInfo);
    return {
        datamodelInfo: importedDatamodelInfo,
        client: importedClient,
    };
}
//# sourceMappingURL=yogaDefaults.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanitizeNumber = exports.getCaretPosition = exports.addGaps = void 0;
var valid = _interopRequireWildcard(require("card-validator"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/

const addGaps = (gaps, value) => gaps.reduce((prev, gap, index) => `${prev.slice(0, gap + index)} ${prev.slice(gap + index)}`.trim(), `${value}`);
exports.addGaps = addGaps;
const sanitizeNumber = input => {
  const number = input.replace(/[^0-9]/gi, '');
  const validatedValue = valid.number(number);
  if (validatedValue.card && Array.isArray(validatedValue.card.lengths)) {
    return number.slice(0, validatedValue.card.lengths[validatedValue.card.lengths.length - 1]);
  }
  // CC number NEVER can have more than 19 digits
  return number.slice(0, 19);
};
exports.sanitizeNumber = sanitizeNumber;
const getCaretPosition = (value, prevValue, position) => {
  const cleanValue = sanitizeNumber(value);
  const validatedValue = valid.number(cleanValue);

  // skipping over a gap
  if (validatedValue.card && Array.isArray(validatedValue.card.gaps)) {
    const gaps = validatedValue.card.gaps;
    const valueWithGaps = addGaps(gaps, cleanValue);
    if (cleanValue.length > prevValue.length && valueWithGaps[position - 1] === ' ') {
      return [position + 1, cleanValue];
    }
  }

  // deleting a gap
  const prevValidatedValue = valid.number(prevValue);
  if (prevValidatedValue.card && Array.isArray(prevValidatedValue.card.gaps)) {
    const gaps = prevValidatedValue.card.gaps;
    const valueWithGaps = addGaps(gaps, prevValue);
    if (prevValue === cleanValue && valueWithGaps.length > value.length) {
      const newValue = valueWithGaps.slice(0, position - 1) + valueWithGaps.slice(position);
      return [position - 1, sanitizeNumber(newValue)];
    }
  }

  // change without crossing a gap
  return [position, cleanValue];
};
exports.getCaretPosition = getCaretPosition;
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs"));
var inquirer = __importStar(require("inquirer"));
var js_yaml_1 = __importDefault(require("js-yaml"));
var path = __importStar(require("path"));
var pluralize_1 = __importDefault(require("pluralize"));
var config_1 = require("../../../config");
var helpers_1 = require("../../../helpers");
var spawnAsync_1 = require("../../spawnAsync");
var execa = require("execa");
exports.default = (function (argv) { return __awaiter(_this, void 0, void 0, function () {
    var _a, yogaConfig, projectDir, hasDb, inputTypeQuestion, inputTypeName, typeName, crudOperations, _b, datamodelPath, datamodelContent, relativeDatamodelPath, retry, exposeCrudOps, operations, allStepsDone, filePath_1, relativePath_1, filePath, relativePath;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                _a = config_1.importYogaConfig({ env: argv.env }), yogaConfig = _a.yogaConfig, projectDir = _a.projectDir;
                hasDb = !!yogaConfig.prisma;
                inputTypeQuestion = {
                    name: 'inputTypeName',
                    message: 'Input the name of your type',
                    type: 'input',
                    validate: function (input) {
                        if (!input || input.length === 0) {
                            return 'Type name should be at least one character';
                        }
                        if (!/^[_a-zA-Z][_a-zA-Z0-9]*$/.test(input)) {
                            return "Type name must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \"" + input + "\" does not";
                        }
                        return true;
                    },
                };
                return [4 /*yield*/, inquirer.prompt(inputTypeQuestion)];
            case 1:
                inputTypeName = (_c.sent()).inputTypeName;
                typeName = upperFirst(inputTypeName);
                if (!hasDb) return [3 /*break*/, 13];
                crudOperations = null;
                _b = getPrismaDatamodel(projectDir), datamodelPath = _b.datamodelPath, datamodelContent = _b.datamodelContent;
                relativeDatamodelPath = path.relative(projectDir, datamodelPath);
                _c.label = 2;
            case 2:
                if (!isModelNameAlreadyDefined(inputTypeName, datamodelContent)) return [3 /*break*/, 4];
                return [4 /*yield*/, inquirer.prompt([
                        __assign({}, inputTypeQuestion, { message: 'Type name already defined in your datamodel. Please try another one:' }),
                    ])];
            case 3:
                retry = (_c.sent()).inputTypeName;
                inputTypeName = retry;
                return [3 /*break*/, 2];
            case 4: return [4 /*yield*/, inquirer.prompt([
                    {
                        name: 'exposeCrudOps',
                        message: 'Do you want to expose CRUD operations ?',
                        type: 'confirm',
                    },
                ])];
            case 5:
                exposeCrudOps = (_c.sent()).exposeCrudOps;
                if (!exposeCrudOps) return [3 /*break*/, 7];
                return [4 /*yield*/, inquirer.prompt([
                        {
                            name: 'operations',
                            message: 'Select the operations you would like to expose',
                            type: 'checkbox',
                            choices: [
                                new inquirer.Separator('Queries'),
                                "Query." + typeName.toLowerCase(),
                                "Query." + pluralize_1.default(typeName.toLowerCase()),
                                new inquirer.Separator('Mutations'),
                                "Mutation.create" + typeName,
                                "Mutation.delete" + typeName,
                                "Mutation.update" + typeName,
                            ],
                        },
                    ])];
            case 6:
                operations = (_c.sent()).operations;
                crudOperations = operations;
                _c.label = 7;
            case 7:
                updateDatamodel(datamodelPath, typeName);
                console.log("\nWe have added a type '" + inputTypeName + "' in your `" + relativeDatamodelPath + "` file !\n\nBefore we continue, please do the following steps:\n\n1. Go to your `" + relativeDatamodelPath + "` file\n2. Add the desired fields to your model\n3. Confirm with Y once you're done, we'll run `prisma deploy` for you\n");
                return [4 /*yield*/, inquirer.prompt([
                        {
                            name: 'allStepsDone',
                            message: 'Did you go through all the steps ?',
                            type: 'confirm',
                        },
                    ])];
            case 8:
                allStepsDone = (_c.sent()).allStepsDone;
                if (!allStepsDone) return [3 /*break*/, 11];
                return [4 /*yield*/, runPrismaDeploy()];
            case 9:
                _c.sent();
                return [4 /*yield*/, scaffoldType(yogaConfig, typeName, hasDb, crudOperations)];
            case 10:
                filePath_1 = _c.sent();
                relativePath_1 = path.relative(projectDir, filePath_1);
                console.log("\nScaffolding of " + relativePath_1 + " succesfuly done !\n  \nA few more optional steps:\n  \n1. Go to " + relativePath_1 + "\n2. Expose/customize your persisted model using `t.prismaFields([...])`\n  ");
                return [3 /*break*/, 12];
            case 11:
                console.log('Exiting now.');
                _c.label = 12;
            case 12:
                process.exit(0);
                _c.label = 13;
            case 13: return [4 /*yield*/, scaffoldType(yogaConfig, typeName, hasDb, null)];
            case 14:
                filePath = _c.sent();
                relativePath = path.relative(projectDir, filePath);
                console.log("Scaffolded new file at " + relativePath + "\n\nNext steps:\n\n- Go to ./src/graphql/" + typeName + ".ts\n- Expose your persisted fields\n    ");
                return [2 /*return*/];
        }
    });
}); });
function scaffoldType(config, typeName, hasDb, crudOperations) {
    return __awaiter(this, void 0, void 0, function () {
        var typePath, content, prettierOptions;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    typePath = path.join(config.resolversPath, typeName + ".ts");
                    if (fs.existsSync(typePath)) {
                        throw new Error("Cannot override existing file at " + typePath + ".");
                    }
                    content = hasDb
                        ? scaffoldTypeWithDb(typeName, crudOperations)
                        : scaffoldTypeWithoutDb(typeName);
                    return [4 /*yield*/, helpers_1.resolvePrettierOptions(process.cwd())];
                case 1:
                    prettierOptions = _a.sent();
                    try {
                        fs.writeFileSync(typePath, helpers_1.prettify(content, prettierOptions));
                    }
                    catch (e) {
                        console.error(e);
                    }
                    return [2 /*return*/, typePath];
            }
        });
    });
}
function scaffoldTypeWithDb(typeName, crudOperations) {
    var content = "import { prismaObjectType" + (crudOperations && crudOperations.length > 0 ? ', prismaExtendType' : '') + " } from 'yoga'\n  \nexport const " + typeName + " = prismaObjectType({\n  name: '" + typeName + "',\n  definition(t) {\n    // All fields exposed thanks the to wildcard operator\n    // Expose, hide or customize specific fields with t.prismaFields(['id', 'otherField', ...])\n    t.prismaFields(['*'])\n  }\n})\n";
    if (crudOperations && crudOperations.length > 0) {
        var queryOperations = crudOperations
            .filter(function (op) { return op.startsWith('Query'); })
            .map(function (op) { return "'" + op.replace('Query.', '') + "'"; });
        var mutationOperations = crudOperations
            .filter(function (op) { return op.startsWith('Mutation'); })
            .map(function (op) { return "'" + op.replace('Mutation.', '') + "'"; });
        if (queryOperations.length > 0) {
            content += "\nexport const " + typeName + "Query = prismaExtendType({\n  type: 'Query',\n  definition(t) {\n    t.prismaFields([" + queryOperations.join(', ') + "])\n  }\n})\n";
        }
        if (mutationOperations.length > 0) {
            content += "\nexport const " + typeName + "Mutation = prismaExtendType({\n  type: 'Mutation',\n  definition(t) {\n    t.prismaFields([" + mutationOperations.join(', ') + "])\n  }\n})\n";
        }
    }
    return content;
}
function scaffoldTypeWithoutDb(typeName) {
    return "import { objectType } from 'yoga'\n\nexport const " + typeName + " = objectType({\n  name: '" + typeName + "',\n  definition(t) {\n    // Expose your fields using t.field()/string()/boolean().. here\n  }\n})\n  ";
}
function getPrismaDatamodel(projectDir) {
    var configPath = config_1.findPrismaConfigFile(projectDir);
    if (!configPath) {
        throw new Error('Could not find `prisma.yml` file');
    }
    var definition = null;
    try {
        var file = fs.readFileSync(configPath, 'utf-8');
        definition = js_yaml_1.default.safeLoad(file);
    }
    catch (e) {
        throw new Error("Yaml parsing error in " + configPath + ": " + e.message);
    }
    if (!definition.datamodel) {
        throw new Error('Missing `datamodel` property in prisma.yml file');
    }
    var unresolvedTypesPath = Array.isArray(definition.datamodel)
        ? definition.datamodel[0]
        : definition.datamodel;
    var datamodelPath = path.join(path.dirname(configPath), unresolvedTypesPath);
    return {
        datamodelPath: datamodelPath,
        datamodelContent: fs.readFileSync(datamodelPath).toString(),
    };
}
function updateDatamodel(datamodelPath, typeName) {
    var typeToAdd = "\n\ntype " + typeName + " {\n  # Add your fields here\n  id: ID! @id\n}";
    try {
        fs.appendFileSync(datamodelPath, typeToAdd);
    }
    catch (e) {
        console.error(e);
    }
}
/**
 * Uppercase the first letter of a string. Useful when generating type names.
 */
function upperFirst(s) {
    return s.replace(/^\w/, function (c) { return c.toUpperCase(); });
}
function isModelNameAlreadyDefined(modelName, datamodelString) {
    return datamodelString.includes("type " + modelName);
}
function runPrismaDeploy() {
    return __awaiter(this, void 0, void 0, function () {
        var e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 4, , 5]);
                    if (!isYarnInstalled()) return [3 /*break*/, 1];
                    if (isPrismaInstalledLocally()) {
                        return [2 /*return*/, runCommand('yarn prisma deploy')];
                    }
                    if (isPrismaInstalledGlobally()) {
                        return [2 /*return*/, runCommand('prisma deploy')];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    if (isPrismaInstalledLocally()) {
                        return [2 /*return*/, runCommand('npm run prisma deploy')];
                    }
                    if (!isPrismaInstalledGlobally()) return [3 /*break*/, 3];
                    return [4 /*yield*/, runCommand("prisma deploy")];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    e_1 = _a.sent();
                    console.error(e_1);
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
function isPrismaInstalledGlobally() {
    return __awaiter(this, void 0, void 0, function () {
        var err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, execa.shell("prisma --version", { stdio: "ignore" })];
                case 1:
                    _a.sent();
                    return [2 /*return*/, true];
                case 2:
                    err_1 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function isPrismaInstalledLocally() {
    return __awaiter(this, void 0, void 0, function () {
        var err_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, execa.shell("yarn prisma --version", { stdio: "ignore" })];
                case 1:
                    _a.sent();
                    return [2 /*return*/, true];
                case 2:
                    err_2 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function isYarnInstalled() {
    return __awaiter(this, void 0, void 0, function () {
        var err_3;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, execa.shell("yarnpkg --version", { stdio: "ignore" })];
                case 1:
                    _a.sent();
                    return [2 /*return*/, true];
                case 2:
                    err_3 = _a.sent();
                    return [2 /*return*/, false];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function runCommand(command) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, cmd, rest, childProcess;
        return __generator(this, function (_b) {
            _a = command.split(' '), cmd = _a[0], rest = _a.slice(1);
            childProcess = spawnAsync_1.spawnAsync(cmd, rest, { stdio: 'inherit' });
            return [2 /*return*/, childProcess];
        });
    });
}
//# sourceMappingURL=index.js.map
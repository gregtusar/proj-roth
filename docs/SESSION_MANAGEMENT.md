# Session Management Architecture

## Overview
This document describes the session management architecture for the NJ Voter Chat application, detailing how chat sessions are created, maintained, and synchronized across the frontend and backend.

## Core Concepts

### Session Identity
Each chat session has a unique identifier (`session_id`) that:
- Is generated by the backend when a conversation starts
- Persists across page refreshes
- Links all messages within a conversation
- Serves as the primary key in both URL routing and data storage

### Session Lifecycle

#### 1. New Chat Initialization
When a user initiates a new chat:
- Frontend routes to `/chat/new`
- Chat interface prepares for user input
- No session exists yet in the backend

#### 2. Session Creation
Upon sending the first message:
- Frontend sends the message without a session_id
- Backend creates a new session in Firestore
- Backend generates a unique session_id
- Backend emits a `session_created` event
- Frontend updates Redux state with the new session
- Frontend navigates to `/chat/{session_id}` using React Router

#### 3. Ongoing Conversation
For subsequent messages in an established session:
- Frontend includes the session_id with each message
- Backend associates messages with the existing session
- All messages are persisted in Firestore
- Message order is maintained via sequence numbers

#### 4. Session Loading
When navigating to an existing session:
- Frontend extracts session_id from URL parameters
- Frontend requests session history from backend
- Backend retrieves messages from Firestore
- Messages are displayed in chronological order

## State Management

### URL State (Source of Truth)
The URL serves as the primary source of truth for the current session:
- `/chat/new` - New chat interface, no session yet
- `/chat/{session_id}` - Active session with established ID

### Redux State
Synchronized with URL state, maintains:
```typescript
{
  currentSessionId: string | null,  // Active session ID
  sessions: ChatSession[],           // List of user's sessions
  messages: Message[],               // Current session messages
}
```

### WebSocket State
Internal state for real-time communication:
- `activeSessionId` - Filters incoming messages
- `isLoadingSession` - Prevents message duplication during loads

## Component Responsibilities

### ChatContainer
- Primary chat interface component
- Reads session_id from URL parameters
- Loads session messages when navigating to existing sessions
- Clears state when starting new chats
- Integrates `useSessionNavigation` hook for proper routing

### MessageInput
- Handles user message composition
- Reads current session_id from Redux
- Sends messages through WebSocket service
- Creates temporary message entries while awaiting confirmation

### WebSocket Service
- Manages Socket.IO connection
- Processes session lifecycle events
- Updates Redux state with session changes
- Handles message streaming and confirmation

### useSessionNavigation Hook
- Monitors Redux session state changes
- Performs React Router navigation when sessions are created
- Ensures URL stays synchronized with session state

## Backend Architecture

### Session Service (Firestore)
- Creates and persists sessions
- Stores message history
- Maintains session metadata
- Provides session retrieval APIs

### WebSocket Handler
- Processes incoming messages
- Creates sessions for new conversations
- Emits session events to frontend
- Manages real-time message streaming

## Data Flow

### New Session Flow
1. User sends first message from `/chat/new`
2. WebSocket service sends message with `session_id: null`
3. Backend creates session and returns new session_id
4. Frontend receives `session_created` event
5. Redux state updates with new session_id
6. useSessionNavigation hook triggers navigation to `/chat/{session_id}`
7. ChatContainer recognizes URL change and updates accordingly

### Existing Session Flow
1. User navigates to `/chat/{session_id}`
2. ChatContainer reads session_id from URL
3. Frontend requests session messages from backend
4. Backend retrieves messages from Firestore
5. Messages populate Redux state and display

## Session Persistence

### Frontend Storage
- Session list cached in Redux
- Current session_id maintained in Redux
- Messages stored in Redux during active session
- Authentication tokens in localStorage

### Backend Storage
- Sessions persisted in Firestore
- Message history maintained permanently
- User associations tracked
- Metadata including timestamps and message counts

## Event Protocol

### WebSocket Events

#### Client → Server
- `send_message`: Transmit user message with optional session_id
- `typing_start/stop`: Typing indicators

#### Server → Client
- `session_created`: New session established with session_id
- `message_confirmed`: User message saved successfully
- `message_start/chunk/end`: Streaming assistant response
- `session_updated`: Session metadata changed

## Security Considerations

- Sessions are user-scoped via authentication
- Only authenticated users can create/access sessions
- Session IDs are cryptographically random
- WebSocket connections require valid JWT tokens
- Backend validates user ownership of sessions

## Best Practices

1. **Single Source of Truth**: URL determines current session
2. **Proper Navigation**: Use React Router for all URL changes
3. **State Synchronization**: Redux follows URL state
4. **Event-Driven Updates**: WebSocket events trigger state changes
5. **Optimistic UI**: Show temporary messages while awaiting confirmation
6. **Error Handling**: Graceful fallbacks for connection issues

## Session Features

- **Automatic Naming**: First message becomes session name
- **Session History**: Full conversation persistence
- **Session List**: Quick access to previous conversations
- **Real-time Updates**: Live message streaming
- **Session Management**: Rename and delete capabilities

## Future Enhancements

- Session sharing capabilities
- Session export functionality
- Multi-user sessions
- Session templates
- Advanced search within sessions
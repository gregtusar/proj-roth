"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var React = _interopRequireWildcard(require("react"));
var _reactFocusLock = _interopRequireDefault(require("react-focus-lock"));
var _locale = require("../locale");
var _overrides = require("../helpers/overrides");
var _layer = require("../layer");
var _constants = require("./constants");
var _styledComponents = require("./styled-components");
var _closeIcon = require("./close-icon");
var _focusVisible = require("../utils/focusVisible");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/ /* global document */
class Modal extends React.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "animateOutTimer", void 0);
    _defineProperty(this, "animateStartTimer", void 0);
    _defineProperty(this, "dialogContainerRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "lastFocus", null);
    _defineProperty(this, "lastMountNodeOverflowStyle", null);
    _defineProperty(this, "rootRef", /*#__PURE__*/React.createRef());
    _defineProperty(this, "state", {
      isVisible: false,
      mounted: false,
      isFocusVisible: false
    });
    _defineProperty(this, "handleFocus", event => {
      if ((0, _focusVisible.isFocusVisible)(event)) {
        this.setState({
          isFocusVisible: true
        });
      }
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _defineProperty(this, "handleBlur", event => {
      if (this.state.isFocusVisible !== false) {
        this.setState({
          isFocusVisible: false
        });
      }
    });
    _defineProperty(this, "onEscape", () => {
      if (!this.props.closeable) {
        return;
      }
      this.triggerClose(_constants.CLOSE_SOURCE.escape);
    });
    _defineProperty(this, "onDocumentClick", e => {
      if (e.target && e.target instanceof HTMLElement && e.target.contains(this.dialogContainerRef.current)) {
        this.onBackdropClick();
      }
    });
    _defineProperty(this, "onBackdropClick", () => {
      if (!this.props.closeable) {
        return;
      }
      this.triggerClose(_constants.CLOSE_SOURCE.backdrop);
    });
    _defineProperty(this, "onCloseClick", () => {
      this.triggerClose(_constants.CLOSE_SOURCE.closeButton);
    });
    _defineProperty(this, "animateOutComplete", () => {
      this.setState({
        isVisible: false
      });
    });
  }
  componentDidMount() {
    this.setState({
      mounted: true
    });
    if (process.env.NODE_ENV !== "production") {
      // @ts-expect-error checking for property with incorrect name
      if (this.props.closable) {
        console.warn('The property `closable` is not supported on the Modal. Did you mean `closeable`?');
      }
    }
  }
  componentWillUnmount() {
    this.resetMountNodeScroll();
    this.clearTimers();
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      isOpen
    } = this.props;
    if (
    // If isOpen is changing *or* we just mounted and modal should be open
    isOpen !== prevProps.isOpen || isOpen && this.state.mounted && !prevState.mounted) {
      if (isOpen) {
        this.didOpen();
      } else {
        this.didClose();
      }
    }
  }
  disableMountNodeScroll() {
    const mountNode = this.getMountNode();
    this.lastMountNodeOverflowStyle = mountNode.style.overflow || '';
    mountNode.style.overflow = 'hidden';
  }
  resetMountNodeScroll() {
    const mountNode = this.getMountNode();
    const lastStyle = this.lastMountNodeOverflowStyle;
    if (mountNode && lastStyle !== null) {
      // If overflow is not 'hidden', something else has changed the
      // overflow style and we shouldn't try to reset it.
      if (mountNode.style.overflow === 'hidden') {
        mountNode.style.overflow = lastStyle || '';
      }
      this.lastMountNodeOverflowStyle = null;
    }
  }
  clearTimers() {
    if (this.animateOutTimer) {
      clearTimeout(this.animateOutTimer);
    }
    if (this.animateStartTimer) {
      cancelAnimationFrame(this.animateStartTimer);
    }
  }
  didOpen() {
    // Sometimes scroll starts past zero, possibly due to animation
    // Reset scroll to 0 (other libraries do this as well)
    const rootRef = this.rootRef.current;
    if (rootRef) {
      rootRef.scrollTop = 0;
    }

    // Clear any existing timers (like previous animateOutTimer)
    this.clearTimers();
    this.disableMountNodeScroll();
    this.animateStartTimer = requestAnimationFrame(() => {
      this.setState({
        isVisible: true
      });
    });
  }
  didClose() {
    this.resetMountNodeScroll();
    this.animateOutTimer = setTimeout(this.animateOutComplete, 500);
  }
  triggerClose(source) {
    // If there's no source, it just means the isOpen prop changed. No need to call onClose.
    if (this.props.onClose && source) {
      this.props.onClose({
        closeSource: source
      });
    }
  }
  getSharedProps() {
    const {
      animate,
      isOpen,
      size,
      role,
      closeable
    } = this.props;
    return {
      // @ts-ignore
      $animate: animate,
      $isVisible: this.state.isVisible,
      $isOpen: !!isOpen,
      // @ts-ignore
      $size: size,
      // @ts-ignore
      $role: role,
      $closeable: !!closeable,
      $isFocusVisible: this.state.isFocusVisible
    };
  }
  getMountNode() {
    const {
      mountNode
    } = this.props;
    if (mountNode) {
      return mountNode;
    }
    // Flow thinks body could be null (cast through any)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return document.body;
  }
  getChildren() {
    const {
      children
    } = this.props;
    return typeof children === 'function' ? children() : children;
  }
  renderModal(renderedContent) {
    const {
      overrides = {},
      closeable,
      role,
      autoFocus,
      focusLock,
      returnFocus
    } = this.props;
    const {
      Root: RootOverride,
      Dialog: DialogOverride,
      DialogContainer: DialogContainerOverride,
      Close: CloseOverride
    } = overrides;
    const [Root, rootProps] = (0, _overrides.getOverrides)(RootOverride, _styledComponents.Root);
    const [DialogContainer, dialogContainerProps] = (0, _overrides.getOverrides)(DialogContainerOverride, _styledComponents.DialogContainer);
    const [Dialog, dialogProps] = (0, _overrides.getOverrides)(DialogOverride, _styledComponents.Dialog);
    const [Close, closeProps] = (0, _overrides.getOverrides)(CloseOverride, _styledComponents.Close);
    const sharedProps = this.getSharedProps();
    return /*#__PURE__*/React.createElement(_locale.LocaleContext.Consumer, null, locale => /*#__PURE__*/React.createElement(_reactFocusLock.default, {
      disabled: !focusLock
      // Allow focus to escape when UI is within an iframe
      ,
      crossFrame: false,
      returnFocus: returnFocus,
      autoFocus: autoFocus
    }, /*#__PURE__*/React.createElement(Root, _extends({
      "data-baseweb": "modal"
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ,
      ref: this.rootRef
    }, sharedProps, rootProps), /*#__PURE__*/React.createElement(DialogContainer
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    , _extends({
      ref: this.dialogContainerRef
    }, sharedProps, dialogContainerProps), /*#__PURE__*/React.createElement(Dialog, _extends({
      tabIndex: -1,
      "aria-modal": true,
      "aria-label": "dialog",
      role: role
    }, sharedProps, dialogProps), renderedContent, closeable ? /*#__PURE__*/React.createElement(Close, _extends({
      "aria-label": locale.modal.close,
      onClick: this.onCloseClick
    }, sharedProps, closeProps, {
      onFocus: (0, _focusVisible.forkFocus)(closeProps, this.handleFocus),
      onBlur: (0, _focusVisible.forkBlur)(closeProps, this.handleBlur)
    }), /*#__PURE__*/React.createElement(_closeIcon.CloseIcon, null)) : null)))));
  }
  render() {
    // Only render an open and non-renderAll modal on the browser (portals aren't supported server-side)
    const mountedAndOpen = this.state.mounted && (this.props.isOpen || this.state.isVisible);
    const renderedContent = mountedAndOpen || this.props.renderAll ? this.getChildren() : null;
    if (renderedContent) {
      if (mountedAndOpen) {
        return /*#__PURE__*/React.createElement(_layer.Layer, {
          onEscape: this.onEscape,
          onDocumentClick: this.onDocumentClick,
          mountNode: this.props.mountNode
        }, this.renderModal(renderedContent));
      } else {
        return /*#__PURE__*/React.createElement(_styledComponents.Hidden, null, renderedContent);
      }
    } else {
      return null;
    }
  }
}
_defineProperty(Modal, "defaultProps", {
  animate: true,
  autoFocus: true,
  focusLock: true,
  returnFocus: true,
  closeable: true,
  name: 'dialog',
  isOpen: false,
  overrides: {},
  role: _constants.ROLE.dialog,
  size: _constants.SIZE.default,
  renderAll: false
});
var _default = exports.default = Modal;
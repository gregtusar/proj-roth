"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MeasureColumnWidths;
var _react = _interopRequireWildcard(require("react"));
var React = _react;
var _styles = require("../styles");
var _headerCell = _interopRequireDefault(require("./header-cell"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/*
Copyright (c) Uber Technologies, Inc.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*/

// Measures the column header + sampled data
// @ts-ignore
function MeasureColumn({
  sampleIndexes,
  column,
  columnIndex,
  rows,
  isSelectable,
  onLayout
}) {
  const [css] = (0, _styles.useStyletron)();
  const ref = (0, _react.useRef)();
  React.useEffect(() => {
    if (typeof document !== 'undefined') {
      if (ref.current) {
        onLayout(columnIndex, ref.current.getBoundingClientRect());
      }
    }
  }, [onLayout]);
  return /*#__PURE__*/React.createElement("div", {
    // @ts-ignore
    ref: ref,
    className: css({
      display: 'flex',
      flexDirection: 'column',
      width: 'fit-content'
    })
  }, /*#__PURE__*/React.createElement(_headerCell.default, {
    index: columnIndex,
    isHovered: true,
    isMeasured: true,
    isSelectedAll: false,
    isSelectedIndeterminate: false,
    onMouseEnter: () => {},
    onMouseLeave: () => {},
    onSelectAll: () => {},
    onSelectNone: () => {}
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ,
    onSort: i => {},
    sortable: column.sortable
    // @ts-ignore
    ,
    sortDirection: null,
    title: column.title,
    isSelectable: isSelectable
  }), sampleIndexes.map((rowIndex, i) => {
    const Cell = column.renderCell;
    return /*#__PURE__*/React.createElement(Cell, {
      key: `measure-${i}`,
      value: column.mapDataToValue(rows[rowIndex].data),
      isSelectable: isSelectable,
      isMeasured: true,
      sortable: column.sortable,
      x: 0,
      y: rowIndex
    });
  }));
}
const MAX_SAMPLE_SIZE = 50;

// @ts-ignore
function generateSampleIndices(inputMin, inputMax, maxSamples) {
  const indices = [];
  const queue = [[inputMin, inputMax]];
  while (queue.length > 0) {
    // @ts-ignore
    const [min, max] = queue.shift();
    if (indices.length < maxSamples) {
      const pivot = Math.floor((min + max) / 2);
      // @ts-ignore
      indices.push(pivot);
      const left = pivot - 1;
      const right = pivot + 1;
      if (left >= min) {
        queue.push([min, left]);
      }
      if (right <= max) {
        queue.push([right, max]);
      }
    }
  }
  return indices;
}
function MeasureColumnWidths({
  columns,
  rows,
  widths,
  isSelectable,
  onWidthsChange
}) {
  const [css] = (0, _styles.useStyletron)();
  const widthMap = React.useMemo(() => {
    return new Map();
  }, [rows]);
  const sampleSize = rows.length < MAX_SAMPLE_SIZE ? rows.length : MAX_SAMPLE_SIZE;
  const finishedMeasurementCount = (sampleSize + 1) * columns.length;
  const sampleIndexes = React.useMemo(() => {
    return generateSampleIndices(0, rows.length - 1, sampleSize);
  }, [columns, rows, widths, sampleSize]);
  const handleDimensionsChange = React.useCallback((columnIndex, dimensions) => {
    const nextWidth = Math.min(Math.max(columns[columnIndex].minWidth || 0, widthMap.get(columnIndex) || 0, dimensions.width + 1), columns[columnIndex].maxWidth || Infinity);
    if (nextWidth !== widthMap.get(columnIndex)) {
      widthMap.set(columnIndex, nextWidth);
    }
    if (
    // Refresh at 100% of done
    widthMap.size === columns.length ||
    // ...50%
    widthMap.size === Math.floor(columns.length / 2) ||
    // ...25%
    widthMap.size === Math.floor(columns.length / 4)) {
      onWidthsChange(Array.from(widthMap.values()));
    }
  }, [columns, rows, finishedMeasurementCount, onWidthsChange]);
  const hiddenStyle = css({
    position: 'absolute',
    overflow: 'hidden',
    height: 0
  });

  // Remove the measurement nodes after we are done updating our column width
  if (widthMap.size === columns.length) {
    return null;
  }
  return /*#__PURE__*/React.createElement("div", {
    className: hiddenStyle,
    "aria-hidden": "true",
    role: "none"
  }, columns.map((column, i) => {
    return /*#__PURE__*/React.createElement(MeasureColumn, {
      key: column.title + i,
      column: column,
      rows: rows,
      isSelectable: isSelectable,
      onLayout: handleDimensionsChange,
      columnIndex: i,
      sampleIndexes: sampleIndexes
    });
  }));
}